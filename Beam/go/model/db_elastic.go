package model

import (
	"context"
	"fmt"
	"math"
	"strconv"

	"github.com/olivere/elastic"
	"github.com/pkg/errors"
)

// ElasticDB represents data layer based on ElasticSearch.
type ElasticDB struct {
	Client  *elastic.Client
	Debug   bool
	Context context.Context

	fieldsCache map[string]map[string]bool // fields cache represents list of all index (map key) fields (map values)
}

// NewElasticDB returns new instance of ElasticSearch DB implementation
func NewElasticDB(ctx context.Context, client *elastic.Client, debug bool) *ElasticDB {
	edb := &ElasticDB{
		Client:  client,
		Debug:   debug,
		Context: ctx,
	}
	edb.fieldsCache = make(map[string]map[string]bool)
	return edb
}

func (eDB *ElasticDB) addFilters(search *elastic.SearchService, index string, o AggregateOptions) (*elastic.SearchService, error) {
	filters := elastic.NewBoolQuery()
	for _, f := range o.FilterBy {
		if len(f.Values) == 0 {
			continue
		}

		// cast to interface slice, see https://github.com/golang/go/wiki/InterfaceSlice
		var interfaceSlice = make([]interface{}, len(f.Values))
		for idx, val := range f.Values {
			interfaceSlice[idx] = val
		}

		field, err := eDB.resolveKeyword(index, f.Tag)
		if err != nil {
			return nil, err
		}
		filters = filters.Must(elastic.NewTermsQuery(field, interfaceSlice...))
	}

	if o.Category != "" {
		field, err := eDB.resolveKeyword(index, "category")
		if err != nil {
			return nil, err
		}
		filters = filters.Must(elastic.NewTermQuery(field, o.Category))
	}
	if o.Action != "" {
		field, err := eDB.resolveKeyword(index, "action")
		if err != nil {
			return nil, err
		}
		filters = filters.Must(elastic.NewTermQuery(field, o.Action))
	}
	if o.Step != "" {
		field, err := eDB.resolveKeyword(index, "step")
		if err != nil {
			return nil, err
		}
		filters = filters.Must(elastic.NewTermQuery(field, o.Step))
	}
	if !o.TimeAfter.IsZero() || !o.TimeBefore.IsZero() {
		rq := elastic.NewRangeQuery("time")
		if !o.TimeAfter.IsZero() {
			rq.Gte(o.TimeAfter)
		}
		if !o.TimeBefore.IsZero() {
			rq.Lt(o.TimeBefore)
		}
		filters = filters.Must(rq)
	}
	search = search.Query(filters)
	return search, nil
}

// addGroupBy creates a standard (wrapped) aggregation. The results are fetchable
// via countRowCollectionFromBuckets or sumRowCollectionFromBuckets.
func (eDB *ElasticDB) addGroupBy(search *elastic.SearchService, index string, o AggregateOptions,
	extras map[string]elastic.Aggregation) (*elastic.SearchService, error) {
	if len(o.GroupBy) > 0 {
		var err error
		search, _, err = eDB.wrapAggregation(index, o.GroupBy, search, extras, nil)
		if err != nil {
			return nil, err
		}
	}
	return search, nil
}

func (eDB *ElasticDB) countRowCollectionFromBuckets(aggregations elastic.Aggregations, options AggregateOptions) (CountRowCollection, bool, error) {
	crc := CountRowCollection{}
	tags := make(map[string]string)

	eDB.unwrapAggregation(aggregations, options.GroupBy, tags, func(tags map[string]string, count int) {
		crcTags := make(map[string]string)
		// copy tags to avoid memory sharing
		for key, val := range tags {
			crcTags[key] = val
		}
		crc = append(crc, CountRow{
			Tags:  crcTags,
			Count: count,
		})
	})

	return crc, true, nil
}

func (eDB *ElasticDB) sumRowCollectionFromBuckets(buckets []*elastic.AggregationBucketKeyItem) (SumRowCollection, bool, error) {
	return SumRowCollection{}, true, nil
}

// addCompositeGroupBy creates a composite aggregation. The results are fetchable
// via countRowCollectionFromCompositeBuckets or sumRowCollectionFromCompositeBuckets.
func (eDB *ElasticDB) addCompositeGroupBy(search *elastic.SearchService, index string, o AggregateOptions) (*elastic.SearchService, error) {
	if len(o.GroupBy) > 0 {
		nestedAgg := elastic.NewCompositeAggregation()
		for _, g := range o.GroupBy {
			f, err := eDB.resolveKeyword(index, g)
			if err != nil {
				return nil, err
			}
			agg := elastic.NewCompositeAggregationTermsValuesSource(g).Field(f)
			nestedAgg = nestedAgg.Sources(agg)
		}

		search = search.Aggregation("buckets", nestedAgg)
	}

	return search, nil
}

// countRowCollectionFromCompositeBuckets extracts CountRow data from buckets generated by composite aggregation query.
func (eDB *ElasticDB) countRowCollectionFromCompositeBuckets(buckets []*elastic.AggregationBucketKeyItem) (CountRowCollection, bool, error) {
	crc := CountRowCollection{}

	for _, bucket := range buckets {
		keys, ok := bucket.Key.(map[string]interface{}) // composite aggregation has map[string]interface{} bucket keys
		if !ok {
			return nil, false, fmt.Errorf("unexpected type of bucket key: %T", bucket.Key)
		}
		tags := make(map[string]string)
		for key, val := range keys {
			switch tag := val.(type) {
			case float64:
				tags[key] = strconv.FormatFloat(tag, 'f', 0, 64)
			case string:
				tags[key] = tag
			default:
				return nil, false, fmt.Errorf("unexpected type of aggregation bucket count: %T", val)
			}
		}
		crc = append(crc, CountRow{
			Tags:  tags,
			Count: int(bucket.DocCount),
		})
	}
	return crc, true, nil
}

// sumRowCollectionFromBuckets extracts SumRow data from buckets generated by composite aggregation query.
func (eDB *ElasticDB) sumRowCollectionFromCompositeBuckets(buckets []*elastic.AggregationBucketKeyItem) (SumRowCollection, bool, error) {
	src := SumRowCollection{}

	for _, bucket := range buckets {
		keys, ok := bucket.Key.(map[string]interface{}) // composite aggregation has map[string]interface{} bucket keys
		if !ok {
			return nil, false, fmt.Errorf("unexpected type of bucket key: %T", bucket.Key)
		}
		tags := make(map[string]string)
		for key, val := range keys {
			switch tag := val.(type) {
			case float64:
				tags[key] = strconv.FormatFloat(tag, 'f', 0, 64)
			case string:
				tags[key] = tag
			default:
				return nil, false, fmt.Errorf("unexpected type of aggregation bucket count: %T", val)
			}
		}
		src = append(src, SumRow{
			Tags: tags,
			Sum:  float64(bucket.DocCount),
		})
	}
	return src, true, nil
}

// resolveKeyword checks, whether the index contains ".keyword" field (for exact indexed search) and uses that if possible.
func (eDB *ElasticDB) resolveKeyword(index, field string) (string, error) {
	fields, ok := eDB.fieldsCache[index]

	// populate cache for given index if it's empty
	if !ok {
		result, err := eDB.Client.GetFieldMapping().Index(index).Type("_doc").Do(eDB.Context)
		if err != nil {
			return "", errors.Wrap(err, "unable to get field mappings for pageviews index")
		}

		root, ok := result[index].(map[string]interface{})
		if !ok {
			return "", fmt.Errorf("invalid index provided, no mapping data available: %s", index)
		}
		mappings, ok := root["mappings"].(map[string]interface{})
		if !ok {
			return "", fmt.Errorf("\"mappings\" field not present within field mapping response")
		}
		doc, ok := mappings["_doc"].(map[string]interface{})
		if !ok {
			return "", fmt.Errorf("invalid document provided, no mapping data available for document: _doc")
		}

		fields = make(map[string]bool)
		for f := range doc {
			fields[f] = true
		}
		eDB.fieldsCache[index] = fields
	}

	// check if keyword is present among fields
	keyword := fmt.Sprintf("%s.keyword", field)
	_, ok = fields[keyword]
	if !ok {
		return field, nil
	}
	return keyword, nil
}

// wrapAggregation recursivelly wraps aggregations based on provided groupBy fields.
//
// It includes any extra aggregations on the lowest level.
//
// Initially the implementation used ElasticDB::addCompositeGroupBy(), but it was a beta feature
// and elastic didn't allow us to link sum aggregation to the results.
//
// Following is a standard wrapping via SubAggregation() endorsed by official docs.
func (eDB *ElasticDB) wrapAggregation(index string, groupBy []string, search *elastic.SearchService,
	extras map[string]elastic.Aggregation, agg *elastic.TermsAggregation) (*elastic.SearchService, *elastic.TermsAggregation, error) {

	for _, field := range groupBy {
		keyword, err := eDB.resolveKeyword(index, field)
		if err != nil {
			return nil, nil, err
		}

		termsAgg := elastic.NewTermsAggregation().Field(keyword).Size(math.MaxInt32)

		if len(groupBy) > 1 {
			search, termsAgg, err = eDB.wrapAggregation(index, groupBy[1:], search, extras, termsAgg)
			if err != nil {
				return nil, nil, err
			}
		}

		if agg == nil {
			// include external aggregation if necessary (e.g. sum)
			for label, extraAgg := range extras {
				search = search.Aggregation(label, extraAgg)
			}
			return search, nil, nil
			// return search.Aggregation(field, termsAgg), nil, nil
		} else {
			// include external aggregation if necessary (e.g. sum)
			for label, extraAgg := range extras {
				agg = agg.SubAggregation(label, extraAgg)
			}
			return search, agg.SubAggregation(field, termsAgg), nil
		}

	}

	return search, nil, nil
}

// unwrapCallback represents final callback that should be called when all aggregations are unwrapped
// and the final set of tags and count can be provided
type unwrapCallback func(tags map[string]string, count int)

// unwrapAggregation traverses through all the aggregations and calls the provided callback on the lowest level
// providing tags of the fields and resulting count.
func (eDB *ElasticDB) unwrapAggregation(aggregations elastic.Aggregations, groupBy []string, tags map[string]string, cb unwrapCallback) error {
	for _, field := range groupBy {
		agg, ok := aggregations.Terms(field)
		if !ok {
			return fmt.Errorf("result is missing data for term aggregation: %s", field)
		}
		for _, bucket := range agg.Buckets {
			switch tag := bucket.Key.(type) {
			case float64:
				tags[field] = strconv.FormatFloat(tag, 'f', 0, 64)
			case string:
				tags[field] = tag
			default:
				return fmt.Errorf("unexpected type of aggregation bucket count: %T", bucket.Key)
			}

			if len(groupBy) > 1 {
				eDB.unwrapAggregation(bucket.Aggregations, groupBy[1:], tags, cb)
				return nil
			}

			cb(tags, int(bucket.DocCount))
		}
	}

	return nil
}
